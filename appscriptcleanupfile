//V2.5.98

function importCSVfromDrive() {
  const folderId = '1Y8tDGKpwFVVWI-2Dkm7tSSMqDHK6BIey';
  const folder = DriveApp.getFolderById(folderId);
  const files = folder.getFilesByType(MimeType.CSV);

  const sheet = SpreadsheetApp.openById('1vDWb4Zj8tP2Z6md9CcbHmm19Rl_bPGydDJw6gURmyaQ').getSheetByName('Sheet1');
  const logSheet = SpreadsheetApp.openById('1vDWb4Zj8tP2Z6md9CcbHmm19Rl_bPGydDJw6gURmyaQ').getSheetByName('log');

  const processedFilesSet = new Set(logSheet.getRange(2, 1, logSheet.getLastRow() - 1, 1).getValues().map(row => row[0]));

  if (!files.hasNext()) {
    Logger.log('No CSV files found in the Dropzone folder.');
    return;
  }

  while (files.hasNext()) {
    const file = files.next();
    const fileName = file.getName();

    if (processedFilesSet.has(fileName)) {
      Logger.log('File already processed: ' + fileName);
      continue;
    }

    const csvData = Utilities.parseCsv(file.getBlob().getDataAsString());
    if (csvData.length > 1) {
      const { rowsProcessed, rowsAppended, rowsRejected } = appendMappedCSVData(csvData, sheet, fileName);

      logSheet.appendRow([fileName, new Date(), rowsProcessed, rowsAppended, rowsRejected]);
    } else {
      Logger.log('CSV file is empty or only contains headers: ' + fileName);
    }
  }
}

function appendMappedCSVData(csvData, sheet, fileName) {
  const headers = csvData.shift();
  const headerMap = headers.reduce((map, header, index) => {
    map[header.trim().toLowerCase()] = index;
    return map;
  }, {});

  const lastRow = sheet.getLastRow();
  const outputData = [];

  // Define processedOrdersSet to track existing order_id, product, and qty combinations
  const processedOrdersSet = new Set(sheet.getRange(2, 1, lastRow - 1, 4).getValues().map(row => `${row[0]}|${row[2]}|${row[3]}`));

  let currentOrder = {
    order_id: '',
    outlet_name: '',
    address: '',
    province: '',
    city: '',
    subdistrict: '',
    zip: '',
    email: '',
    phone: '',
    status: '',
    payment_status: '',
    payment_method: '',
    created_at: '',
    paid_at: '',
    processing_at: '',
    completed_at: ''
  };

  let lastNonEmptyValues = { ...currentOrder };
  let lastDiscount = '';

  const grossRevenueMap = {};

  csvData.forEach(row => {
    Object.keys(currentOrder).forEach(key => {
      const headerKey = key === 'outlet_name' ? 'name' : key;
      const value = row[headerMap[headerKey]];

      if (value && value.trim() !== '') {
        currentOrder[key] = value;
        lastNonEmptyValues[key] = value;
      } else {
        currentOrder[key] = lastNonEmptyValues[key];
      }
    });

    const productDetails = extractProductDetails(row[headerMap['product']] || '');

    if (currentOrder.order_id) {
      grossRevenueMap[currentOrder.order_id] = (grossRevenueMap[currentOrder.order_id] || 0) + productDetails.price * productDetails.qty;
    }
  });

  let rowsProcessed = 0;
  let rowsAppended = 0;
  let rowsRejected = 0;

  csvData.forEach(row => {
    rowsProcessed++;

    Object.keys(currentOrder).forEach(key => {
      const headerKey = key === 'outlet_name' ? 'name' : key;
      const value = row[headerMap[headerKey]];

      if (value && value.trim() !== '') {
        currentOrder[key] = value;
        lastNonEmptyValues[key] = value;
      } else {
        currentOrder[key] = lastNonEmptyValues[key];
      }
    });

    const productDetails = extractProductDetails(row[headerMap['product']] || '');

    let discount = '';
    if (currentOrder.order_id && grossRevenueMap[currentOrder.order_id]) {
      const grossRevenue = grossRevenueMap[currentOrder.order_id];
      const netRevenue = parseFloat(row[headerMap['net_revenue']].replace(/\./g, '').replace(',', '.'));
      discount = ((grossRevenue - netRevenue) / grossRevenue) * 100;
      discount = isNaN(discount) ? lastDiscount : discount.toFixed(2) + '%';
      lastDiscount = discount;
    }

    const mappedRow = [
      currentOrder.order_id,
      currentOrder.outlet_name,
      productDetails.product,
      productDetails.qty,
      productDetails.price,
      '=master_b2b[qty]*master_b2b[price]',
      discount,
      '=master_b2b[total_price]*master_b2b[discount]',
      '=master_b2b[total_price]-master_b2b[potongan_harga]',
      currentOrder.address,
      currentOrder.province,
      currentOrder.city,
      currentOrder.subdistrict,
      currentOrder.zip,
      currentOrder.email,
      currentOrder.phone,
      currentOrder.status,
      currentOrder.payment_status,
      currentOrder.payment_method,
      convertStringToDateOnly(currentOrder.created_at),
      convertStringToDateOnly(currentOrder.paid_at),
      convertStringToDateOnly(currentOrder.processing_at),
      convertStringToDateOnly(currentOrder.completed_at)
    ];

    const status = mappedRow[16];
    const key = `${mappedRow[0]}|${mappedRow[2]}|${mappedRow[3]}`;

    if (status.toLowerCase() === 'completed' && !processedOrdersSet.has(key)) {
      outputData.push(mappedRow);
      processedOrdersSet.add(key);
      rowsAppended++;
    } else {
      rowsRejected++;
    }
  });

  if (outputData.length > 0) {
    sheet.getRange(lastRow + 1, 1, outputData.length, outputData[0].length).setValues(outputData);
  }

  return {
    rowsProcessed,
    rowsAppended,
    rowsRejected
  };
}

function convertStringToDateOnly(dateString) {
  if (!dateString) return null;
  const [datePart] = dateString.split(' - ');
  if (!datePart) return null;
  const [day, month, year] = datePart.split('-').map(Number);
  const date = new Date(year, month - 1, day);
  return isNaN(date.getTime()) ? null : date;
}

function extractProductDetails(productString) {
  const productRegex = /^(.*) - ([\d.,]+)\s*\(x(\d+)\)$/;
  const match = productString.match(productRegex);
  if (match) {
    return {
      product: match[1].trim(),
      price: parseFloat(match[2].replace(/\./g, '').replace(',', '.')),
      qty: parseInt(match[3])
    };
  }

  const complexRegex = /^(.*)\s-\s(\d+[\d.,]*)\)\s*\(x(\d+)\)$/;
  const complexMatch = productString.match(complexRegex);
  if (complexMatch) {
    return {
      product: complexMatch[1].trim(),
      price: parseFloat(complexMatch[2].replace(/\./g, '').replace(',', '.')),
      qty: parseInt(complexMatch[3])
    };
  }

  return { product: productString, price: 0, qty: 0 };
}
